## 每日分享
### 第一小题  
- //题目描  // 移除数组 arr 中的所有值与 item 相等的元素，直接在给定arr 数组上进行操作，并将结果返回


<<<<<<< HEAD
###  浏览器上的拖拉事件
- 拖拉（drag）指的是，用户在某个对象上按下鼠标键不放，拖动它到另一个位置，然后释放鼠标键，将该对象放在那里。
=======

>>>>>>> 977eeeb6cb0391ba6902e8cdd381fb38f60de159

拖拉的对象有好几种，包括元素节点、图片、链接、选中的文字等等。在网页中，除了元素节点默认不可以拖拉，其他（图片、链接、选中的文字）都是可以直接拖拉的。为了让元素节点可拖拉，可以将该节点的draggable属性设为true。

- 当元素节点或选中的文本被拖拉时，就会持续触发拖拉事件，包括以下一些事件。

- drag：拖拉过程中，在被拖拉的节点上持续触发（相隔几百毫秒）。
- dragstart：用户开始拖拉时，在被拖拉的节点上触发，该事件的target属性是被拖拉的节点。通常应该在这个事件的监听函数中，指定拖拉的数据。
- dragend：拖拉结束时（释放鼠标键或按下 ESC 键）在被拖拉的节点上触发，该事件的target属性是被拖拉的节点。它与dragstart事件，在同一个节点上触发。不管拖拉是否跨窗口，或者中途被取消，dragend事件总是会触发的。
- dragenter：拖拉进入当前节点时，在当前节点上触发一次，该事件的target属性是当前节点。通常应该在这个事件的监听函数中，指定是否允许在当前节点放下（drop）拖拉的数据。如果当前节点没有该事件的监听函数，或者监听函数不执行任何操作，就意味着不允许在当前节点放下数据。在视觉上显示拖进入当前节点，也是在这个事件的监听函数中设置。
- dragover：拖拉到当前节点上方时，在当前节点上持续触发（相隔几百毫秒），该事件的target属性是当前节点。该事件与dragenter事件的区别是：dragenter事件在进入该节点时触发，然后只要没有离开这个节点，dragover事件会持续触发。
- dragleave：拖拉操作离开当前节点范围时，在当前节点上触发，该事件的target属性是当前节点。如果要在视觉上显示拖拉离开操作当前节点，就在这个事件的监听函数中设置。
- drop：被拖拉的节点或选中的文本，释放到目标节点时，在目标节点上触发。注意，如果当前节点不允许drop，即使在该节点上方松开鼠标键，也不会触发该事件。如果用户按下 ESC 键，取消这个操作，也不会触发该事件。该事件的监听函数负责取出拖拉数据，并进行相关处理。

### 总结 
- 事件拖拽一共经历了6 个阶段
  -  第一：dragstart ,用户刚拖拽时就立刻在被拖拉的节点上触发
  -  第二：dragend, 拖拉结束，该事件也在被拖拉的节点触发
  -  第三：dragover, 拖拉到目标节点的上方，当前目标节点事件持续触发。
  -  第三：dragenter, 拖拉进入当前目标节点，在当前节点上会触发一次。
  -  第四：dragleave, 拖拉离开当前节点范围时，在当前节点⬆️触发。
  -  第五：drop, 被拖拉的节点，释放到目标节点时，会触发这个事件。这个节点可以触发添加节点或者删除节点。

  ## EventTarget。addEventListener()
  ### `EventTarget.addEventListener()` 用于在当前节点或者对象傻姑娘，定义一个特定的事件的监听函数。一旦这个事情发生之后，就会执行监听函数，该方法是没有返回值的 。
  - `target.addEventListener(type,listener[,userCapture])`
  该方法接收三个参数 。
    - **type** :事件名称，大小写敏感，不含on 
    - **listener** : 监听的事件函数，事件发生时，会执行该事件函数
    - **useCapture**: 可选参数（布尔类型的值） ，表示监听的事件函数是否在捕获阶段执行，如果参数是true，则在捕获阶段执行。为false则在冒泡阶段执行！ 默认参数为false。 大多情况下可以不写！
  - 第二个参数除了可以是一个监听函数之外，还可以是一个handleEvent方法对象。`target.addEventListener('click',{ handleEvent:function(e){console.log(e)}})` // 第三个参数就不写了
  - 第三个参数不仅可以选，还可以设置。
